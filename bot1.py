import telebot
import subprocess
import sys
import json
from requests import post, Session
import time
import datetime
import threading
from urllib.parse import urlparse
import psutil
import tempfile
import random
from gtts import gTTS
import re
import string
import os
import base64
import hashlib
from flask import Flask, request
from telebot.types import Message
from threading import Lock
import requests
import sqlite3
from telebot import types
from time import strftime
import queue
import pytz
from datetime import timedelta
from keep_alive import keep_alive
keep_alive()
BOT_TOKEN = os.environ.get('BOT_TOKEN')  # <- th√™m d√≤ng n√†y
bot = telebot.TeleBot(BOT_TOKEN)         # <- bot d√πng bi·∫øn n√†y

print(BOT_TOKEN)  # Ki·ªÉm tra token c√≥ t·ªìn t·∫°i kh√¥ng
print("Bot ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông th√†nh c√¥ng")
admin_diggory = "HaoEsport" 
name_bot = "Tr·∫ßn H√†o"
ADMIN_ID = '7658079324'
zalo = "0585019743"
web = "https://dichvukey.site/"
facebook = "no"
users_keys = {}
key = ""
user_cooldown = {}
active_processes = {}
last_usage = {} 
share_log = []
auto_spam_active = False
last_sms_time = {}
global_lock = Lock()
allowed_users = []
processes = []
admin_mode = False
ADMIN_ID = 7658079324 #nh·ªõ thay id nh√© n·∫øu k thay k duy·ªát dc vip ƒë√¢u v.L..ong.a
allowed_group_id = -1002639856138
connection = sqlite3.connect('user_data.db')
cursor = connection.cursor()
last_command_time = {}

last_command_timegg = 0



def check_command_cooldown(user_id, command, cooldown):
    current_time = time.time()
    
    if user_id in last_command_time and current_time - last_command_time[user_id].get(command, 0) < cooldown:
        remaining_time = int(cooldown - (current_time - last_command_time[user_id].get(command, 0)))
        return remaining_time
    else:
        last_command_time.setdefault(user_id, {})[command] = current_time
        return None

cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        expiration_time TEXT
    )
''')
connection.commit()

def TimeStamp():
  now = str(datetime.date.today())
  return now

#vLong zz#v
def load_users_from_database():
  cursor.execute('SELECT user_id, expiration_time FROM users')
  rows = cursor.fetchall()
  for row in rows:
    user_id = row[0]
    expiration_time = datetime.datetime.strptime(row[1], '%Y-%m-%d %H:%M:%S')
    if expiration_time > datetime.datetime.now():
      allowed_users.append(user_id)


def save_user_to_database(connection, user_id, expiration_time):
  cursor = connection.cursor()
  cursor.execute(
    '''
        INSERT OR REPLACE INTO users (user_id, expiration_time)
        VALUES (?, ?)
    ''', (user_id, expiration_time.strftime('%Y-%m-%d %H:%M:%S')))
  connection.commit()
###

vietnam_tz = pytz.timezone('Asia/Ho_Chi_Minh')


###
#zalo ...07890416.31

####
start_time = time.time()



video_url = 'https://v16m-default.akamaized.net/b7650db4ac7f717b7be6bd6a04777a0d/66a418a5/video/tos/useast2a/tos-useast2a-ve-0068-euttp/o4QTIgGIrNbkAPGKKLKteXyLedLE7IEgeSzeE2/?a=0&bti=OTg7QGo5QHM6OjZALTAzYCMvcCMxNDNg&ch=0&cr=0&dr=0&lr=all&cd=0%7C0%7C0%7C0&cv=1&br=2576&bt=1288&cs=0&ds=6&ft=XE5bCqT0majPD12cy-773wUOx5EcMeF~O5&mime_type=video_mp4&qs=0&rc=Mzk1OzY7PGdpZjxkOTQ3M0Bpajh1O2w5cmlzbzMzZjgzM0AuNWJgLi02NjMxLzBgXjUyYSNzNmptMmRjazFgLS1kL2Nzcw%3D%3D&vvpl=1&l=202407261543513F37EAD38E23B6263167&btag=e00088000'
@bot.message_handler(commands=['add', 'adduser'])
def add_user(message):
    admin_id = message.from_user.id
    if admin_id != ADMIN_ID:
        bot.reply_to(message, 'B·∫°n Kh√¥ng Ph·∫£i admin')
        return

    if len(message.text.split()) == 1:
        bot.reply_to(message, 'VUI L√íNG NH·∫¨P ID NG∆Ø·ªúI D√ôNG V√Ä S·ªê NG√ÄY')
        return
    if len(message.text.split()) == 2:
        bot.reply_to(message, 'H√ÉY NH·∫¨P S·ªê NG√ÄY')
        return
    user_id = int(message.text.split()[1])
    allowed_users.append(user_id)
    days = int(message.text.split()[2])
    expiration_time = datetime.datetime.now() + datetime.timedelta(days)
    connection = sqlite3.connect('user_data.db')
    save_user_to_database(connection, user_id, expiration_time)
    connection.close()

    caption_text = (f'<blockquote>NG∆Ø·ªúI D√ôNG C√ì ID {user_id}\nƒê√É ƒê∆Ø·ª¢C TH√äM V√ÄO DANH S√ÅCH VIP\nTH·ªúI GIAN: {days} DAY\nL·ªÜNH C√ì TH·ªÇ S·ª¨ D·ª§NG C√ÅC L·ªÜNH TRONG [/start]</blockquote>')
    bot.send_video(
        message.chat.id,
        video_url,
        caption=caption_text, parse_mode='HTML')

load_users_from_database()

def is_key_approved(chat_id, key):
    if chat_id in users_keys:
        user_key, timestamp = users_keys[chat_id]
        if user_key == key:
            current_time = datetime.datetime.now()
            if current_time - timestamp <= datetime.timedelta(hours=2):
                return True
            else:
                del users_keys[chat_id]
    return False




@bot.message_handler(commands=['bot','start'])
def send_help(message):
    bot.reply_to(message, """<blockquote>
‚îå‚îÄ‚îÄ‚îÄ‚≠ì Tr·∫ßn H√†o
‚û§ /spam : Spam FREE
‚û§ /spamvip : Spam Vip
‚û§ /stop : D·ª´ng Spam SƒêT
‚û§ /tv : Ti·∫øng vi·ªát cho telegram
‚û§ /id : L·∫•y id b·∫£n th√¢n
‚îî‚îÄ‚îÄ‚îÄTi·ªán √çch Kh√°c
‚û§ /like : Buff Like FF
‚û§ /searchff : T√¨m T√™n Acc ff
‚û§ /voice : Chuy·ªÉn vƒÉn b·∫£n th√†nh gi·ªçng n√≥i 
‚û§ /hoi : h·ªèi gamini 
‚û§ /tiktokinfo : xem th√¥ng tin tiktok
‚û§ /tkey : M√£ Ho√° File .py
‚îî‚îÄ‚îÄ‚îÄContact
‚û§ /admin : Li√™n H·ªá admin
‚û§ /themvip : Th√™m Vip
‚îî‚îÄ‚îÄ‚îÄ
</blockquote>""", parse_mode="HTML")
### /like
API_BASE_URL = "https://dichvukey.site/freefire/like.php?key=vLong161656"

def call_api(uid):
    url = f"{API_BASE_URL}&uid={uid}"
    try:
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36"
        }
        response = requests.get(url, headers=headers, timeout=10)
        response.raise_for_status()
        return response.json()
    except requests.exceptions.RequestException:
        return {"status": "error", "message": "Server ƒëang b·ªã admin T·∫Øt"}

@bot.message_handler(commands=['like'])
def like_handler(message):
    args = message.text.split()
    
    if len(args) != 2:
        bot.reply_to(message, "<blockquote>üîπ C√°ch d√πng: /like [UID]</blockquote>", parse_mode="HTML")
        return

    uid = args[1]

    # G·ª≠i th√¥ng b√°o "loading"
    loading_msg = bot.reply_to(message, "<i>‚è≥ ƒêang ti·∫øn h√†nh buff like...</i>", parse_mode="HTML")

    data = call_api(uid)

    if data.get("status") == "error":
        bot.edit_message_text(
            f"<blockquote>‚ùå {data['message']}</blockquote>",
            chat_id=loading_msg.chat.id,
            message_id=loading_msg.message_id,
            parse_mode="HTML"
        )
        return

    reply_text = (
        f"<blockquote>\n"
        f"üéØ <b>K·∫øt qu·∫£ buff like:</b>\n"
        f"üë§ <b>T√™n:</b> {data.get('username', 'T·∫°m Th·ªùi L·ªói')}\n"
        f"üÜî <b>UID:</b> {data.get('uid', 'Kh√¥ng x√°c ƒë·ªãnh')}\n"
        f"üëç <b>Like tr∆∞·ªõc:</b> {data.get('likes_before', 'T·∫°m Th·ªùi L·ªói')}\n"
        f"‚úÖ <b>Like sau:</b> {data.get('likes_after', 'T·∫°m Th·ªùi L·ªói')}\n"
        f"‚ûï <b>T·ªïng c·ªông:</b> {data.get('likes_given', 'T·∫°m Th·ªùi L·ªói')} like\n"
        f"</blockquote>"
    )

    bot.edit_message_text(
        reply_text,
        chat_id=loading_msg.chat.id,
        message_id=loading_msg.message_id,
        parse_mode="HTML"
    )

VIP_FILE = "vip_users.txt"

def is_user_vip(user_id):
    if not os.path.exists(VIP_FILE):
        return False
    with open(VIP_FILE, "r") as f:
        return str(user_id) in f.read()

def save_vip_user(user_id):
    with open(VIP_FILE, "a") as f:
        f.write(f"{user_id}\n")



ADMIN_ID = 7658079324  # thay b·∫±ng ID Telegram c·ªßa b·∫°n

@bot.message_handler(commands=['themvip'])
def themvip(message: Message):
    if message.from_user.id != ADMIN_ID:
        bot.reply_to(message, "üö´ B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng l·ªánh n√†y.")
        return

    parts = message.text.split()
    if len(parts) != 2 or not parts[1].isdigit():
        bot.reply_to(message, "‚ùì D√πng ƒë√∫ng c√∫ ph√°p: /themvip <user_id>")
        return

    user_id_to_add = int(parts[1])
    save_vip_user(user_id_to_add)
    bot.reply_to(message, f"‚úÖ ƒê√£ th√™m ID {user_id_to_add} v√†o danh s√°ch VIP.")



@bot.message_handler(commands=['voice'])
def text_to_voice(message):
    text = message.text[7:].strip()  
  
    
    if not text:
        bot.reply_to(message, 'Nh·∫≠p n·ªôi dung ƒëi VD : /voice T√¥i l√† bot')
        return

    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix='.mp3') as temp_file:
            tts = gTTS(text, lang='vi')
            tts.save(temp_file.name)
            temp_file_path = temp_file.name  
       
        with open(temp_file_path, 'rb') as f:
            bot.send_voice(message.chat.id, f, reply_to_message_id=message.message_id)
    
    except Exception as e:
        bot.reply_to(message, f'ƒê√£ x·∫£y ra l·ªói: {e}')
    
    finally:
        if os.path.exists(temp_file_path):
            os.remove(temp_file_path)




@bot.message_handler(commands=['hoi'])
def handle_hoi(message):
    text = message.text[len('/hoi '):].strip()
    

    # N·∫øu h·ª£p l·ªá, cho spam
    if text:
        url = f"https://dichvukey.site/apishare/hoi.php?text={text}"
        response = requests.get(url)
        
        if response.status_code == 200:
            data = response.json()
            reply = data.get("message", "Kh√¥ng c√≥ ph·∫£n h·ªìi.")
        else:
            reply = "L·ªói."
    else:
        reply = "L·ªánh V√≠ D·ª• : /hoi xin ch√†o."
    bot.reply_to(message, reply)


@bot.message_handler(commands=['searchff'])
def search_ff(message):
    args = message.text.split(maxsplit=1)
    if len(args) < 2:
        bot.reply_to(message, "‚ö†Ô∏è D√πng nh∆∞ n√†y: /searchff t√™n_ng∆∞·ªùi_ch∆°i")
        return

    name = args[1].strip()
    loading = bot.send_message(message.chat.id, f"üîç ƒêang t√¨m ki·∫øm `{name}`...", parse_mode="Markdown")

    try:
        response = requests.get(f"https://ariflexlabs-search-api.vercel.app/search?name={name}")
        if response.status_code == 200:
            data = response.json()
            if not data:
                bot.edit_message_text("‚ùå Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i n√†o v·ªõi t√™n ƒë√≥.", message.chat.id, loading.message_id)
                return

            # L·∫•y danh s√°ch k·∫øt qu·∫£ v√† format
            result_msg = f"üéÆ K·∫øt qu·∫£ t√¨m ki·∫øm cho: *{name}*\n\n"
            for i, user in enumerate(data, start=1):
                uid = user.get("uid", "Kh√¥ng r√µ")
                name_result = user.get("name", "Kh√¥ng r√µ")
                result_msg += f"{i}. üìõ *{name_result}*\nüÜî UID: `{uid}`\n\n"

            bot.edit_message_text(result_msg, message.chat.id, loading.message_id, parse_mode="Markdown")
        else:
            bot.edit_message_text("‚ö†Ô∏è Kh√¥ng th·ªÉ truy c·∫≠p API. Vui l√≤ng th·ª≠ l·∫°i sau.", message.chat.id, loading.message_id)

    except Exception as e:
        bot.edit_message_text(f"‚ùå L·ªói khi g·ªçi API: {str(e)}", message.chat.id, loading.message_id)



@bot.message_handler(commands=['time'])
def handle_time(message):
    uptime_seconds = int(time.time() - start_time)
    
    uptime_minutes, uptime_seconds = divmod(uptime_seconds, 60)
    bot.reply_to(message, f'Bot ƒë√£ ho·∫°t ƒë·ªông ƒë∆∞·ª£c: {uptime_minutes} ph√∫t, {uptime_seconds} gi√¢y')



@bot.message_handler(commands=['id', 'ID'])
def handle_id_command(message):
    if message.reply_to_message:  
        user_id = message.reply_to_message.from_user.id
        first_name = message.reply_to_message.from_user.first_name
        bot.reply_to(message, f"ID c·ªßa {first_name} l√†: `{user_id}`", parse_mode='Markdown')
    elif len(message.text.split()) == 1:
        if message.chat.type in ["group", "supergroup"]:
            chat_id = message.chat.id
            chat_title = message.chat.title
            bot.reply_to(message, f"ID c·ªßa nh√≥m n√†y l√†: `{chat_id}`\nT√™n nh√≥m: {chat_title}", parse_mode='Markdown')
        else:
            user_id = message.from_user.id
            first_name = message.from_user.first_name
            bot.reply_to(message, f"ID c·ªßa b·∫°n l√†: `{user_id}`\nT√™n: {first_name}", parse_mode='Markdown')


   
def detect_carrier(phone_number: str) -> str:
    phone_number = phone_number.strip().replace("+84", "0")
    prefixes = {
        "Viettel": ["086", "096", "097", "098", "032", "033", "034", "035", "036", "037", "038", "039"],
        "Mobifone": ["089", "090", "093", "070", "076", "077", "078", "079"],
        "Vinaphone": ["088", "091", "094", "081", "082", "083", "084", "085"],
        "Vietnamobile": ["092", "056", "058"],
        "Gmobile": ["099", "059"],
    }

    for name, prefix_list in prefixes.items():
        if any(phone_number.startswith(p) for p in prefix_list):
            return name
    return "Kh√¥ng x√°c ƒë·ªãnh"


def animate_loading(chat_id, message_id, stop_event):
    emojis = ['‚è≥', '‚åõ']
    idx = 0
    while not stop_event.is_set():
        try:
            bot.edit_message_text(
                f"{emojis[idx % 2]} ƒêang x·ª≠ l√Ω...",
                chat_id=chat_id,
                message_id=message_id
            )
            idx += 1
            time.sleep(1)
        except Exception as e:
            print(f"L·ªói khi update loading: {e}")
            break

@bot.message_handler(commands=['spam'])
def spam(message):
    user_id = message.from_user.id
    current_time = time.time()

    if user_id in last_usage and current_time - last_usage[user_id] < 10:
        bot.reply_to(message, f"‚è≥ Vui l√≤ng ƒë·ª£i {10 - (current_time - last_usage[user_id]):.1f} gi√¢y tr∆∞·ªõc khi d√πng l·∫°i.")
        return

    params = message.text.split()[1:]
    if len(params) != 2:
        warn = bot.reply_to(message, "/spam sdt s·ªë_l·∫ßn nh∆∞ n√†y c∆° m√†")
        time.sleep(5)
        try:
            bot.delete_message(message.chat.id, warn.message_id)
            bot.delete_message(message.chat.id, message.message_id)
        except:
            pass
        return

    sdt, count = params
    carrier = detect_carrier(sdt)

    if not count.isdigit():
        bot.reply_to(message, "S·ªë l·∫ßn spam kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªâ nh·∫≠p s·ªë.")
        return

    count = int(count)

    if count > 25:
        bot.reply_to(message, "/spam sdt s·ªë_l·∫ßn t·ªëi ƒëa l√† 25 - ƒë·ª£i 10 gi√¢y s·ª≠ d·ª•ng l·∫°i.")
        return

    if sdt in blacklist:
        bot.reply_to(message, f"S·ªë ƒëi·ªán tho·∫°i {sdt} ƒë√£ b·ªã c·∫•m spam.")
        return

    sdt_request = f"84{sdt[1:]}" if sdt.startswith("0") else sdt
    username = message.from_user.username if message.from_user.username else "Kh√¥ng c√≥ username"

    diggory_chat3 = f'''‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì {name_bot}
‚îÇ üöÄ Attack Sent Successfully
‚îÇ üí≥ Plan Free: Min 1 | Max 5
‚îÇ üìû Phone: {sdt}
‚îÇ ‚öîÔ∏è Attack By: @{username}
‚îÇ ‚è≥ Delay: 20s
‚îÇ üìé V√≤ng L·∫∑p: {count}
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì
'''

    script_filename = "dec.py"
    try:
        if not os.path.isfile(script_filename):
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y file script.")
            return

        # G·ª≠i loading ban ƒë·∫ßu
        loading_msg = bot.send_message(message.chat.id, "‚è≥ ƒêang x·ª≠ l√Ω...")

        # B·∫Øt ƒë·∫ßu hi·ªáu ·ª©ng loading ƒë·ªông
        stop_loading = threading.Event()
        loading_thread = threading.Thread(
            target=animate_loading,
            args=(message.chat.id, loading_msg.message_id, stop_loading)
        )
        loading_thread.start()

        # ƒê·ªçc n·ªôi dung file script
        with open(script_filename, 'r', encoding='utf-8') as file:
            script_content = file.read()

        with tempfile.NamedTemporaryFile(delete=False, suffix=".py") as temp_file:
            temp_file.write(script_content.encode('utf-8'))
            temp_file_path = temp_file.name

        # Ch·∫°y script spam
        process = subprocess.Popen(["python", temp_file_path, sdt, str(count)])
        active_processes[sdt] = process

        # D·ª´ng hi·ªáu ·ª©ng loading v√† x√≥a tin nh·∫Øn ƒë√≥
        stop_loading.set()
        bot.delete_message(chat_id=message.chat.id, message_id=loading_msg.message_id)

        # G·ª≠i k·∫øt qu·∫£
        bot.send_message(
            message.chat.id,
            f'<blockquote>{diggory_chat3}</blockquote>',
            parse_mode='HTML'
        )

        last_usage[user_id] = current_time

    except FileNotFoundError:
        bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y file.")
    except Exception as e:
        bot.reply_to(message, f"L·ªói x·∫£y ra: {str(e)}")

@bot.message_handler(commands=['spamvip'])
def spam(message):
    user_id = message.from_user.id
    current_time = time.time()

    if not is_user_vip(user_id):
        bot.reply_to(message, "üö´ Ch·ªâ d√†nh cho ng∆∞·ªùi d√πng VIP!")
        return

    if not bot_active:
        msg = bot.reply_to(message, 'Bot hi·ªán ƒëang t·∫Øt.')
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Error deleting message: {e}")
        return

    if admin_mode and user_id not in admins:
        msg = bot.reply_to(message, 'c√≥ l·∫Ω admin ƒëang fix g√¨ ƒë√≥ h√£y ƒë·ª£i x√≠u')
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        except telebot.apihelper.ApiTelegramException as e:
            print(f"Error deleting message: {e}")
        return

    if user_id in last_usage and current_time - last_usage[user_id] < 10:
        warn_msg = bot.reply_to(message, f"‚è≥ Vui l√≤ng ƒë·ª£i {100 - (current_time - last_usage[user_id]):.1f} gi√¢y tr∆∞·ªõc khi d√πng l·∫°i.")
        time.sleep(10)
        try:
            bot.delete_message(chat_id=message.chat.id, message_id=warn_msg.message_id)
        except:
            pass
        return

    # Ph√¢n t√≠ch c√∫ ph√°p
    params = message.text.split()[1:]
    if len(params) != 2:
        msg = bot.reply_to(message, "/spamvip sdt s·ªë_l·∫ßn")
        time.sleep(10)
        bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        return

    sdt, count = params
    carrier = detect_carrier(sdt)

    if not count.isdigit():
        msg = bot.reply_to(message, "S·ªë l·∫ßn spam kh√¥ng h·ª£p l·ªá. Vui l√≤ng ch·ªâ nh·∫≠p s·ªë.")
        time.sleep(10)
        bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        return

    count = int(count)

    if count > 100:
        msg = bot.reply_to(message, "/spamvip sdt s·ªë_l·∫ßn t·ªëi ƒëa l√† 100 - ƒë·ª£i 100 gi√¢y s·ª≠ d·ª•ng l·∫°i.")
        time.sleep(10)
        bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        return

    if sdt in blacklist:
        msg = bot.reply_to(message, f"S·ªë ƒëi·ªán tho·∫°i {sdt} ƒë√£ b·ªã c·∫•m spam.")
        time.sleep(10)
        bot.delete_message(chat_id=message.chat.id, message_id=msg.message_id)
        return

    sdt_request = f"84{sdt[1:]}" if sdt.startswith("0") else sdt

    username = message.from_user.username if message.from_user.username else "Kh√¥ng c√≥ username"
    first_name = message.from_user.first_name
    diggory_chat3 = f'''‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚≠ì {name_bot}
‚îå‚îÄ‚îÄ‚îÄ‚≠ì
¬ª {first_name} | @{username}
¬ª ID [{user_id}]
‚îî‚îÄ‚îÄ‚îÄ‚ßï

‚îå‚îÄ‚îÄ‚îÄ‚≠ì
¬ª Server: Spam SMS VIP
¬ª ƒêang Ti·∫øn H√†nh Spam: [ {sdt} ]
¬ª Nh√† M·∫°ng: [ {carrier} ]
¬ª V√≤ng L·∫∑p Spam: {count}
¬ª D·ª´ng Spam [/stop {sdt}]
‚îî‚îÄ‚îÄ‚îÄ‚ßï
'''

    script_filename = "dec.py"
    try:
        if not os.path.isfile(script_filename):
            bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y file script.")
            return

        with open(script_filename, 'r', encoding='utf-8') as file:
            script_content = file.read()

        with tempfile.NamedTemporaryFile(delete=False, suffix=".py") as temp_file:
            temp_file.write(script_content.encode('utf-8'))
            temp_file_path = temp_file.name

        # Ch·∫°y script spam
        process = subprocess.Popen(["python", temp_file_path, sdt, str(count)])
        active_processes[sdt] = process
        # G·ª≠i k·∫øt qu·∫£ spam
        sent_msg = bot.send_message(
            message.chat.id,
            f'<blockquote>{diggory_chat3}</blockquote>\n<blockquote>G√ìI NG∆Ø·ªúI D√ôNG: VIP</blockquote>',
            parse_mode='HTML'
        )

        threading.Thread(
        target=lambda: (
        time.sleep(0),
        bot.delete_message(chat_id=message.chat.id, message_id=message.message_id)
    )
).start()

        last_usage[user_id] = current_time

    except FileNotFoundError:
        bot.reply_to(message, "Kh√¥ng t√¨m th·∫•y file.")
    except Exception as e:
        bot.reply_to(message, f"L·ªói x·∫£y ra: {str(e)}")


blacklist = ["112", "113", "114", "115", "116", "117", "118", "119", "0", "1", "2", "3", "4"]



@bot.message_handler(commands=['stop'])
def stop_spam(message):
    args = message.text.split()
    if len(args) != 2:
        bot.reply_to(message, "D√πng ƒë√∫ng c√∫ ph√°p: /stop 098xxxxxxx")
        return

    sdt = args[1]
    process = active_processes.get(sdt)

    if process:
        process.terminate()  # D·ª´ng ti·∫øn tr√¨nh
        del active_processes[sdt]  # X√≥a kh·ªèi danh s√°ch
        bot.reply_to(message, f"‚õîÔ∏è ƒê√£ d·ª´ng spam s·ªë {sdt}")
    else:
        bot.reply_to(message, f"Kh√¥ng t√¨m th·∫•y ti·∫øn tr√¨nh spam v·ªõi s·ªë {sdt}. C√≥ th·ªÉ ƒë√£ ho√†n th√†nh ho·∫∑c sai s·ªë.")




@bot.message_handler(commands=['tiktokinfo'])
def get_tiktok_info(message):
    chat_id = message.chat.id
    args = message.text.split()

    if len(args) < 2:
        bot.send_message(chat_id, "‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n ng∆∞·ªùi d√πng TikTok!\nV√≠ d·ª•: /tiktokinfo ho.esports", parse_mode="Markdown")
        return

    username = args[1]
    api_url = f"https://api.sumiproject.net/tiktok?info={username}"

    try:
        response = requests.get(api_url)
        data = response.json()

        if data['code'] != 0 or 'data' not in data:
            bot.send_message(chat_id, "‚ùå Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n TikTok!", parse_mode="Markdown")
            return

        user = data['data']['user']
        stats = data['data']['stats']

        profile_message = f"""
======[ ùôèùôÑùôÜùôèùôäùôÜ ùôÑùôâùôÅùôä ]======  

üë§ T√™n hi·ªÉn th·ªã: {user['nickname']}  
üÜî Username: @{user['uniqueId']}  
üîó Profile: [Xem tr√™n TikTok](https://www.tiktok.com/@{user['uniqueId']})  

üìä Th·ªëng k√™:  
‚îú üë• Ng∆∞·ªùi theo d√µi: {stats['followerCount']}  
‚îú üë§ ƒêang theo d√µi: {stats['followingCount']}  
‚îú ‚ù§Ô∏è T·ªïng l∆∞·ª£t th√≠ch: {stats['heartCount']}  
‚îú üé• S·ªë video: {stats['videoCount']}  

üîó M·∫°ng x√£ h·ªôi kh√°c:  
{f"‚ñ∂Ô∏è [YouTube](https://www.youtube.com/channel/{user['youtube_channel_id']})" if user.get('youtube_channel_id') else "üö´ Kh√¥ng c√≥ YouTube"}  
{f"üìå Bio: {user['signature']}" if user.get('signature') else "üö´ Kh√¥ng c√≥ m√¥ t·∫£"}  
        """

        bot.send_photo(chat_id, user['avatarLarger'], caption=profile_message, parse_mode="Markdown")

    except Exception as error:
        bot.send_message(chat_id, "‚ö†Ô∏è L·ªói khi l·∫•y th√¥ng tin t√†i kho·∫£n TikTok!", parse_mode="Markdown")
        print(error)


TEMP_DIR = "temp_files"
os.makedirs(TEMP_DIR, exist_ok=True)

# Bi·∫øn ƒë·ªÉ ch·ª©a key v√† s·ªë l·∫ßn nh·∫≠p
key_attempts = 1
current_key = None

def generate_random_key(length=30):
    characters = 'haoesportQWERTYUIOPASDFGHJKLZXCVBBNM123456789'
    return ''.join(random.choice(characters) for i in range(length))


@bot.message_handler(commands=['tkey'])
def create_key(message):
    global current_key, key_attempts
    current_key = generate_random_key()  # T·∫°o key ng·∫´u nhi√™n
    key_attempts = 1  # S·ªë l·∫ßn nh·∫≠p m·∫∑c ƒë·ªãnh l√† 1
    bot.send_message(message.chat.id, f"Key ƒë√£ ƒë∆∞·ª£c t·∫°o: {current_key}\nB·∫°n c√≥ {key_attempts} l·∫ßn g·ª≠i file\nvui l√≤ng g·ª≠i file. py")

@bot.message_handler(content_types=['document'])
def handle_document(message):
    global key_attempts, current_key

    if current_key is None:
        bot.send_message(message.chat.id, "Vui l√≤ng t·∫°o key tr∆∞·ªõc khi g·ª≠i file b·∫±ng l·ªánh /tkey.")
        return

    file_info = bot.get_file(message.document.file_id)
    file_extension = message.document.file_name.split('.')[-1]

    if file_extension != 'py':
        bot.send_message(message.chat.id, "Vui l√≤ng g·ª≠i m·ªôt file .py h·ª£p l·ªá.")
        return

    if key_attempts <= 0:
        bot.send_message(message.chat.id, "S·ªë l·∫ßn g·ª≠i file ƒë√£ h·∫øt. Vui l√≤ng t·∫°o l·∫°i key.")
        return

    downloaded_file = bot.download_file(file_info.file_path)
    original_filename = message.document.file_name
    file_path = os.path.join(TEMP_DIR, original_filename)

    with open(file_path, 'wb') as new_file:
        new_file.write(downloaded_file)

    key_attempts -= 1  # Gi·∫£m s·ªë l·∫ßn g·ª≠i file sau khi nh·∫≠n file

    # G·ª≠i th√¥ng ƒëi·ªáp loading v√† b·∫Øt ƒë·∫ßu hi·ªáu ·ª©ng loading
    msg = bot.reply_to(message, "ƒêang m√£ h√≥a...", parse_mode='HTML')
    
    time.sleep(2)  # M√¥ ph·ªèng x·ª≠ l√Ω

    obfuscated_file_path = obfuscate_file(file_path, current_key, message.from_user)

    # Tin nh·∫Øn cu·ªëi c√πng tr∆∞·ªõc khi g·ª≠i file
    bot.send_message(message.chat.id, "M√£ h√≥a ho√†n t·∫•t! ƒêang g·ª≠i file...")
    
    with open(obfuscated_file_path, 'rb') as obfuscated_file:
        bot.send_document(message.chat.id, obfuscated_file)

    os.remove(file_path)
    os.remove(obfuscated_file_path)

def obfuscate_file(file_path, key, user):
    random_number = random.randint(99738, 101290)
    obfuscated_filename = f"file-{random_number}.py"
    obfuscated_file_path = os.path.join(TEMP_DIR, obfuscated_filename)

    with open(file_path, 'r', encoding='utf-8') as file:
        code = file.read()

    encoded_code = base64.b64encode(code.encode('utf-8')).decode('utf-8')
    hash_object = hashlib.sha256(code.encode('utf-8'))
    hash_code = hash_object.hexdigest()

    username = user.username if user.username else "Kh√¥ng C√¥ng Khai"
    user_id = user.id

    current_time = datetime.datetime.utcnow() + datetime.timedelta(hours=7)

    time_vietnam = current_time.strftime('%Y-%m-%d %H:%M:%S')

    obfuscated_code = f"""
# ENCODE BY HAOESPORTS
# Key: {key}
# Trial version
# Username Obf: @{username} ({user_id})
# Obf Time: {time_vietnam}

import base64
import hashlib

expected_hash = '{hash_code}'
current_hash = hashlib.sha256(base64.b64decode('{encoded_code}')).hexdigest()
if current_hash != expected_hash:
    raise Exception("I am bot enc test version.")

exec(base64.b64decode('{encoded_code}').decode('utf-8'))
"""

    with open(obfuscated_file_path, 'w', encoding='utf-8') as obf_file:
        obf_file.write(obfuscated_code)

    return obfuscated_file_path




@bot.message_handler(commands=['tv'])
def tieng_viet(message):
    chat_id = message.chat.id
    keyboard = types.InlineKeyboardMarkup()
    url_button = types.InlineKeyboardButton("Ti·∫øng Vi·ªát üáªüá≥", url='https://t.me/setlanguage/vi')
    keyboard.add(url_button)
    bot.send_message(chat_id, '<blockquote>Click v√†o n√∫t "<b>Ti·∫øng Vi·ªát</b>" ƒë·ªÉ ƒë·ªïi ng√¥n ng·ªØ sang Ti·∫øng Vi·ªát üáªüá≥</blockquote>', reply_markup=keyboard, parse_mode='HTML')
######

# H√†m g·ªçi API T
def react_to_message(chat_id, message_id, emoji="‚ù§Ô∏è"):
    url = f"https://api.telegram.org/bot{os.environ.get('BOT_TOKEN')}/setMessageReaction"
    payload = {
        "chat_id": chat_id,
        "message_id": message_id,
        "reaction": [{"type": "emoji", "emoji": emoji}],
        "is_big": True
    }
    requests.post(url, json=payload)

import random

# Danh s√°ch emoji tu·ª≥ th√≠ch
emojis = ["‚ù§Ô∏è", "üòÇ", "üî•", "ü§î", "üëç", "üòç", "üòé", "üíØ", "üëè", "üò¢", "üò°"]

@bot.message_handler(func=lambda message: True)
def auto_like(message):
    emoji = random.choice(emojis)  # L·∫•y emoji ng·∫´u nhi√™n
    react_to_message(message.chat.id, message.message_id, emoji=emoji)



if __name__ == "__main__":
    bot_active = True
    bot.polling()  #
